# V2X-Reg++ 中 SVD 对应关系的补充说明

## 1. 大白话版

对 V2X-Reg++ 来说，SVD 这一步只会把“已经配对好的点”拿来求刚体变换，所以**必须先知道“哪辆车匹配哪辆车”“再知道这辆车的 8 个角点一一对应”**。流水线本身正好把这两件事拆成两层：

1. **物体级别**：`MatchingEngine` 通过 oDist/oIoU 把同一辆车（或同一辆卡车、公交等）在路端/车端的检测框对上——这解决了“哪对盒子相互对应”。  
2. **盒子内部的 8 个角点**：DAIR-V2X 的标注格式并不是随便吐 8 个点，而是“先用一个固定模板（车头沿 +X、左边沿 +Y、底面 z=0、顶面 z=h）生成角点，再用物体在该传感器坐标系下的 yaw 和平移把模板旋转/平移过去”。换句话说，每个盒子都带了“物体朝向”这一锚点，车端和路端都按同一个模板+yaw 来构造角点，所以序号天然一致。

这就是为什么我们在实验里只要把其中一侧的角点顺序打乱，SVD 就立刻崩溃；而两侧同时用同一个乱序却还能跑——SVD 不需要“只有一种顺序”，它需要的是“两侧顺序一致”。只要你遵守“模板 → yaw → 角点”这条链路，顺序一致就自动得到保障。

## 2. 学术化表述

### 2.1 物体级别的对应关系

V2X-Reg++ 的匹配阶段由 `MatchingEngine`（参见 `calib/matching/engine.py`）实现：  
1. 依据类别和 oDist（或 oIoU）计算两端检测框的相似度矩阵；  
2. 使用匈牙利算法挑选最大权匹配，从而确定“基础设施侧盒子 i 与车侧盒子 j 对应”。  
这一步保留了物体级的 correspondences，但不关心盒子内部的点。换言之，给 SVD 的是“哪对盒子需要一起处理”。

### 2.2 盒子内部的顶点对应

每个 `BBox3d` 通过 `legacy/v2x_calib/utils/get_bbox3d_8_3_from_xyz_lwh_yaw` 生成八个角点，该函数依次执行：
1. 在局部坐标系中构造 canonical 角点集合  
   `[(±l/2, ±w/2, 0), (±l/2, ±w/2, h)]`。  
2. 将 canonical 角点按照物体在该传感器坐标系下的 `yaw` 旋转；  
3. 加上 `center` 平移，使其落在 LiDAR 坐标系的实际位置。

由于 DAIR-V2X 明确规定 LiDAR 坐标系为右手系、`x` 指前、`y` 指左、`z` 指上，且 `yaw` 采用相同的正方向定义，所有盒子的角点在构建时都遵循同一模板 → yaw → 平移的过程。这样一来，基础设施侧和车侧对同一物体的角点索引天然一致；`Matches2Extrinsics` 只需把匹配框的 `bbox3d_8_3` 依序拼接，便可直接调用 `get_extrinsic_from_two_points_weighted`（参见 `legacy/v2x_calib/utils/extrinsic_utils.py`）估计刚体变换。

### 2.3 推论与实验支撑

1. **必要性**：若匹配阶段只保留一个盒子，但盒子内部角点顺序不同，则 SVD 会错误地将无关点对齐，导致求解发散。实测（`configs/pipeline_hkust_vertexshuffle.yaml`）中仅打乱车侧角点顺序后，`success_with_matches@1m` 下降至 0。  
2. **充分性**：若两侧采用相同的重排（即便不是 canonical 顺序），SVD 仍可得到正确解（参见 `configs/pipeline_hkust_vertexshuffle_both.yaml`），说明“顺序一致”而非“唯一顺序”才是关键。  
3. **实践启示**：一旦引入只输出角点的第三方检测器，必须在进入匹配前把角点 canonicalize——例如先反算 `(center, l, w, h, yaw)`，再按模板顺序重建。否则就无法满足 SVD 的先决条件。

综上，V2X-Reg++ 通过“物体级匹配 + 盒子模板化”这一组合，构造了一个从检测框到角点的双层对应关系，使得 SVD 在 3D 点集之间能够直接应用闭式解。新的 `success_with_matches` 指标也能帮助我们快速识别任何破坏这一假设的改动。

---

## 3. 对“非检测框特征”的启示

若将来尝试用其他几何/特征来替代 Box 输入（例如关键点集合、语义线段或 feature map），需要重新满足上述“两层对应关系”：

1. **对象级匹配仍需存在。** 当前的 oDist/oIoU 设计在“一个物体一个盒子”的假设下工作。换成稠密特征后，可以考虑：
   - 先将特征聚类成“伪对象”，再复用原匹配器；
   - 或设计新的图匹配/上下文匹配算法，直接输出稳定的一对一或一对多配对。

2. **每个对象内部必须 canonicalize 特征点。** 没有 `center + lwh + yaw` 模板时，需要人为地建立局部坐标：
   - 例如对特征点做 PCA/局部轴对齐，确定一个一致的 basis；
   - 或直接回归 `(center, orientation)`，再用同样的模板生成“伪角点”；
   - 总之要确保传入 `Matches2Extrinsics` 的点集在两侧有相同的索引顺序，否则 SVD 仍然会把错误的点对齐。

3. **多特征混合时要额外注意权重和去重。** 一辆车可能对应多种局部特征，需要事先在对象内部做聚合或加权，避免把重复或噪声点重复送入 SVD。

如果无法明确建立一一对应，不妨考虑那些支持 outlier/partial match 的配准算法（如 ICP、TEASER++ 或基于 RANSAC 的方法）。但只要我们还能把特征规整成“对象级配对 + 对象内部 canonical 点集”，当前的 SVD 求解器就仍然适用。*** End Patch
